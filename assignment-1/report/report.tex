\documentclass[11pt]{article}
\input{preamble.tex}


\title{Tree Pattern Evaluation using SAX}
\author{Friso Abcouwer \and Matthijs van Dorth}

\begin{document}

\maketitle

\section{Introduction}
In this report we will show how we implemented an algorithm for evaluating tree-pattern queries using SAX. SAX (Simple API for XML) is a way to parse XML document using a stream of data in contrast to DOM (Document Object Model) which is a complete representation of the XML file as a tree.

The parser we created reads a query and an xml file and can display the result of the query in various formats. An example query is given in Listing \ref{lst:query1}

\lstinputlisting[label=lst:query1,caption=Query 1,float=h]{query1.xquery}

Given an XML file such as the one given in the book and in figure \ref{lst:people}, the query will return all email and last name nodes of the person nodes that have a email and last name node.
The result is a table or an XML file with these values.

\lstinputlisting[label=lst:people,caption=people.xml,float=h]{people.xml}

\newpage
\section{The Structure of the Algorithm}
The algorithm that we created has several parts. First there is the PatternNode class that represents a single node in a xml document, such as the node with a name "email". Each node can have a value such as "a@work".
When executing a query a TPEStack is created. A TPEStack consists of a PatternNode and a list of child TPEStacks. The TPEStack for Listing \ref{lst:query1} can be constructed with the Java code shown in Listing \ref{lst:tpestackexample}. 

\lstinputlisting[label=lst:tpestackexample,caption=Construction of a TPEStack for Query 1,float=h]{personstack.java}

The TPEStack is used by the StackEval algorithm to create a Match object when a elementname matches the
name of the PatternNode. The most important methods of this StackEval algorithm are \lstinline{startElement}; which is called everytime a opening tag is encountered, \lstinline{endElement}; which is called everytime a closing tag is found and \lstinline{characters}; which is called when text nodes are found. 

These Match objects keep a record of the TPEStack that was matched against this object and all the child Match object children that still need to get Matched agains a PatternNode. 

Once Matches are found, the result is saved into a Result object. This result object has an id, parentId, name, value and depth at which the match was found. This Object is Comparable so that we can sort them on their id. All these results are saved into a ResultList object that is able to print out the results as a table or as XML. 

%\lstinputlisting[label=lst:result,caption=Fields of the Result object,float=h]{Result.java}

\newpage
\section{The Extended Algorithm}
\subsection{Wildcards}
We proceeded with extending the algorithm further by allowing wildcards into the queries. We gave the PatternNode an extra boolean field wildcard which can be set to true or false. In the StackEval algorithm we had to adopt the \lstinline{startElement} and \lstinline{endElement} methods to also match when a wildcard was found, this was a minor change. The way the results had to be printed had to be altered though since we needed to retrieve the name of the node in case of printing it as XML or print it with a wildcard symbol *, when printing it in a table.

\subsection{Printing the result as XML}
The result of the query can be printed out as valid XML. This is done by a method in the ResultList class, that encloses the result in results tags and then prints the opening tags in order and puts the closing stacks on a stack for later printing. When there are no more results the closing tags are popped from the stack and printed. The depth of each result is used to indent the text.

\subsection{Creating a TPEStack from a Query}
The InputParser is an object that is created from a XQuery String and is able to create a TPEStack from this String. An XQuery is a FLWOR expression that consists of several parts, some of them optional. In our parser we didn't add the support for the Let clause, but the other parts are supported.
The for-clause and in-clause selects from which variable the parser should iterate. For example in Listing \ref{lst:query1} line 1, we are only interested in descendants of the person node, that have an email and name/last descendant. 
In
Where
Return
\todo{TODO: explain how the InputParser works}

\newpage
\section{Testing the parser}
Using several different XML files we tested the parser with different queries. The query which we showed in Listing \ref{lst:query1} and was tested against the XML file shown in Listing \ref{lst:people}. The result can be shown using a table as was done in the book \cite{abiteboul2012web} or as valid XML as will be shown in Listing \ref{lst:resultxml}.

\lstinputlisting[label=lst:resultxml, caption=The result of running Query 1 on people.xml,float=h]{result.xml}

As can be seen, only the values of email and last are printed out. Because the person with the last name "Lang" does not have a email adress, only his last name is printed out. In the table this would have resulted in a \lstinline{null} value. 

\newpage
\lstlistoflistings

\bibliographystyle{plain}
\bibliography{references}

\end{document}
